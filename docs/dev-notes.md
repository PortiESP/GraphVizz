# Developer notes

This file is intended to provide information that helps developers understand the project structure, how certain features work, and how to contribute to the project.

> See also the README files of the `graph-manager` and `canvas-component` for more information about the code located in those folders.

# Examples

The examples page `/examples` contains a list of templates that demonstrate how to use the GraphVizz Tool. 

## Add a new example

To add a new example we need to follow these steps:

1. Prepare two files: 
   - The graph file as a `.json` file (can be generated by the export option of the tool) that contains the graph data. This file must be placed in the `/public/examples` folder.
   - The image file as React component (usually used as *svg* on top of the `vite-plugin-svgr`) file that represents the thumbnail of the example. This file must be placed in the `/examples/thumbnails` folder.
2. Add the example file (`.json`) to the `/public/examples` folder. The name of the file must be unique and must be the same as the `id` (*see below*) of the example.
3. Create a new object in the `EXAMPLES` array in the `Examples.js` file. The object must contain the following properties:
      - `id`: A unique identifier for the example (used above as the name of the file containing the example in the `/public` folder).
      - `title`: The title of the example.
      - `description`: A brief description of the example.
      - `thumbnail`: A JSX element that renders the thumbnail of the example 


# Routes

The project uses the `react-router-dom` library to manage the routes. The routes are defined in the `App.js` file.

The header of the application is shared among all the pages. 

## Add a new route

To add a new route we need to follow these steps:

1. Create a new component in the `/src/components` folder.
2. Add a new key to the `ROUTES` array in the `App.jsx` file. 
   - The key will be the path of the route.
   - The value will be the component that will be rendered when the route is accessed.


# Hamburger menu

The hamburger menu is located in the header of the application. It is used to navigate between the different pages of the application or trigger certain actions.

## Add a new menu item

To add a new menu item we need to follow these steps in the `components/header/hamburger-menu/Hamburger.jsx` file:

1. Create a new arrow function in the `HamburgerMenu` component that will be executed when the menu item is clicked.
2. Import the icon that will be displayed next to the menu item.
3. Add a new `<MenuItem>` component within the `<menu></menu>` tags. The component must contain the following properties:
   - `label`: The text that will be displayed as the menu item.
   - `onClick`: The arrow function created in step 1.
   - `icon`: The icon imported in step 2.
   - `shortcut`: The shortcut that will be displayed next to the menu item. (*Optional*)
  
*Use the previous menu items as a reference to create the new one.*


## Modal

The modal component is used by the Hamburger menu to display additional information or actions. The modal is not reusable and is used only in the Hamburger menu.

The modal is based on scenes defined in the `modal/Modal.jsx` file.

### Add a new scene

To add a new scene we need to follow these steps in the `components/header/hamburger-menu/modal/Modal.jsx` file:

1. Create a component that will be the content of the scene in `modal/scenes` folder.
2. Import the component created in step 1 in the `Modal.jsx` file.
3. Add a new key to the `SCENES` object in the `Modal.jsx` file. 
   - The key will be the id (what ever you want) of the scene.
   - The value will be the component created in step 1.

> To display the new scene, we need to call the `setModal` function with the id of the scene as a parameter in the `Hamburger.jsx` file, typically on the onClick event of a menu item.


# Nav 

## Nav items

### Add a new navigation item

To add a new navigation item we edit the `Nav.jsx` file. There are two types of navigation items: `Link` and `SubMenu`.
- `Link`: A simple navigation item that redirects to a different page. Just modify URL (*both in the `className` and the `to`*) and text.
  ```html
  <li className={location.pathname === "/examples" ? scss.current : undefined}><Link to="/examples">Examples</Link></li>
   ```
- `SubMenu`: A navigation item that displays a list of sub-items when clicked.
  ```html
   <SubMenu>
      <div></div>
      <div></div>
   </SubMenu>
  ```

### Add an algorithm, arrangement, etc. To the algorithms submenu

To add a new algorithm, arrangement, etc. to the algorithms submenu we need to go to the `nav/AlgorithmsSubMenu.jsx` there we can add find the arrays for this categories. To add an item to any of these arrays we need to follow add an object with the following properties:
- `title`: The label of the item. (*E.G.: Dijkstra*)
- `icon`: The icon that will be displayed next to the item. (*E.G.: <DijkstraIcon />*)
- `callback`: The function that will be executed when the item is clicked. (*E.G.: () => doSomething()*)

> Usually, the callback function will call the `setViewProps` and the `setView` functions to display a view with the algorithm in case we need to ask for additional information to the user. In this case, it depends on the view to be displayed, but we will usually have a key in the object passed to the `setViewProps` function that will be also `callback` and that will be called when the user interacts with the view, passing the of the user interaction to the callback function.

```jsx
// Example 
{
    title: "Depth First Search (DFS)",
    icon: () => <DFSIcon />,
    callback: () => {
        setViewProps({
            title: "Choose the initial node",
            callback: (selectedNode) => {
                const adjList = generateAdjacencyList()
                const startNode = window.graph.nodes.find(node => node.id === selectedNode)
                const { result, prevNode } = dfs(adjList, startNode)
                const edges = generateEdgesByPredecessors(prevNode)
                result.forEach((node, i) => node.bubble = i)
                window.graph.edges.forEach(edge => edge.hidden = !edges.includes(edge))
            }
        })
        setView("select-node")
    }
}
```

## Views

The views are just a state of the application after running an algorithm where the graph is temporarily altered to show/hide additional information. Some views may display a menu with options to interact with the view.

The views are defined in the `header/nav/views` folder.

> When a view is active, in the nav will appear a new option where we can choose the options to show the view menu or close the view.

### Add a new view

To add a new view we need to follow these steps:

1. Create a new component in the `header/nav/views` folder.
   - The component receive the props 
     - `setView` function to set a different view
     - `setHiddenView` function to hide the current view menu
     - `options` Object with the data of the state `viewProps` that can be filled with data by the caller that triggered the view.
2. Import the component created in step 1 in the `Nav.jsx` file.
3. Add the view to the `// Views` section in the JSX of the `Nav.jsx` file. (*Use the previous views as a reference to create the new one*)

### Display a view

To display a view we need to call the `setViewProps` function with an object as a parameter containing the data that the view requires. Then, we call the `setView` function with the id of the view as a parameter. 

```jsx
setViewProps({
    option1: "value1",
    option2: "value2"
    // ...
})
setView("my-view")
```

### Views callbacks

When the user interacts with the view, the view will call the callback function passed in the `setViewProps` function with the user interaction as a parameter.

```jsx
setViewProps({
    title: "Choose the initial node",
    callback: (selectedNode) => {
        const adjList = generateAdjacencyList()
        const startNode = window.graph.nodes.find(node => node.id === selectedNode)
        const { result, prevNode } = dfs(adjList, startNode)
        const edges = generateEdgesByPredecessors(prevNode)
        result.forEach((node, i) => node.bubble = i)
        window.graph.edges.forEach(edge => edge.hidden = !edges.includes(edge))
    }
})
setView("select-node")
```

If the callback provided in the `setViewProps` function returns a valid JSX element, the view will display the result of the callback function. This is useful when the view needs to display additional information to the user such as a list of nodes, edges, tables, etc.

```jsx
setViewProps({
    title: "Choose the initial node",
    callback: (selectedNode) => {
        const adjList = generateAdjacencyList()
        const startNode = window.graph.nodes.find(node => node.id === selectedNode)
        const { result, prevNode } = dfs(adjList, startNode)
        const edges = generateEdgesByPredecessors(prevNode)
        result.forEach((node, i) => node.bubble = i)
        window.graph.edges.forEach(edge => edge.hidden = !edges.includes(edge))
        return <div>
            <h2>Result</h2>
            <p>Nodes visited: {result.length}</p>
            <p>Edges visited: {edges.length}</p>
        </div>
    }
})
setView("select-node")
```

# Help page

The help page is located in the `/src/components/help` folder. The help page contains information about the tools, how to use it, and how to contribute to the project.

## Add a new section

To add a new section we need to add a `<section id="my-section">` tag within the `<main>` tag, providing a unique id for the section. The section must contain a `<h2>` tag with the title of the section. And additionally `<h3>` tags for subsections.

### Add a toggle subsection

To add a toggle subsection we need to add a `<Toggle>` component within the `<section>` tag. Providing the title prop with the title of the subsection and the children prop with the content of the subsection.

```html
<Toggle title="My subsection">
    <p>Content of the subsection</p>
</Toggle>
```

### Add a shortcut

Copy and paste the `<li>` item and fill it with the new shortcut information.


# ElementEditor

The ElementEditor is a component that allows the user to edit the properties of the selected elements. The ElementEditor is located in the `/src/components/overlays/element-editor` folder.

- When no element is selected, the ElementEditor shows the global properties of the graph/canvas. 
- When multiple elements are selected, the ElementEditor shows the properties that can be edited in common for all the selected elements. If elements of different types are selected, the ElementEditor splits in sections the properties that can be edited for each type of element and applies the changes to all the elements of the same type as the section the user is editing.

## Add a new option to the ElementEditor menu

To add a new edit option we need add it in the `generateEditorOptions.js` file.

Here you will find the `generateOptions` function that will return the sections with the fields that will be displayed in the ElementEditor. If no element is selected, the ElementEditor will show the global properties of the graph/canvas. If one element is selected, the ElementEditor will show the properties of the selected element. If multiple elements are selected, the ElementEditor will show the properties that can be edited in common for all the selected elements, or it will split the properties in sections if the elements are of different types.

- To add a global property edit the `globalOptions` function.
- To add an element property edit the `elementOptions` function.

### Edit the options

To add a new section:

```js
sections.push({
    title: "Section title",
    fields: []
})
```

To add a new field to a section:

```js
fields.push({
    type: "field type",
    label: "Field label",
    initial: initial value,
    callback: callback function,
    checkError: error checking function,
    default: default value,
    disabled: is field disabled,
})
```

> Some field types have an additional `options` field where you can add attributes for the `<input>` tag. See the `widgets/` folder for more information on each field type.


# ToolBar

The ToolBar is a component that allows the user to interact with the graph. The ToolBar is located in the `/src/components/overlays/tool-bar` folder.

### Add a new item to the ToolBar

Edit the `tools` array in the `ToolBar.jsx` file. The array contains the tools that will be displayed in the ToolBar. Each tool is an object with the following properties:

- `id`: The id of the tool. This id is used to identify the active tool. (*Must match the tool name in the graph manager constants*)
- `className`: The class name of the tool. This class is used to identify if the item is a tool, a separator, etc.
- `title`: Title used when the mouse hovers over the tool.
- `icon`: Icon shown in the toolbar.
- `tooltip`: Text shown in the tooltip when the user activates the tool.
- `shortcut`: Keyboard shortcut to activate the tool. (*This is esthetic, the actual shortcut is set in the graph manager*)
- `action`: Function to call when the tool is clicked. 